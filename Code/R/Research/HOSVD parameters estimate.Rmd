---
title: "Parameters estimation via HOSVD"
output: html_document
---
```{r, setup, include=FALSE}
library(Rssa)
library(rTensor)
library(ggplot2)
library(gridExtra)
library(factoextra)
library(dplyr)
library(tidyr)
library(waldo)
library(beepr)

knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

# Функции для тензоризации SSA
```{r tensorization}
tens3 <- function(s, I, L, kind = c("HO-SSA", "HO-MSSA")) {
  require("rTensor")
  if (identical(kind[1], "HO-SSA")) {
    N <- length(s)
    J <- N - I - L + 2
    X <- outer(1:I, 1:L, `+`) |>
      outer(1:J, function(il, j)
        s[il + j - 2]) |> as.tensor()
  }
  else if (identical(kind[1], "HO-MSSA")) {
    if (missing(L))
      L <- I
    N <- nrow(s)
    K <- N - L + 1
    Q <- ncol(s)
    X <- apply(s, 2, Rssa::hankel, L = L, simplify = FALSE) |>
      Reduce(cbind, x = _) |>
      rTensor::fold(1, 2:3, modes = c(L, K, Q))
  }
  return(X)
}

reconstruct.group3 <- function(X.tens) {
  stopifnot(is(X.tens, "Tensor"))
  X <- X.tens@data
  I <- length(X[, 1, 1])
  L <- length(X[1, , 1])
  J <- length(X[1, 1,])
  s <- vector(mode = "numeric", length = I + L + J - 2)
  for (C in 3:(I + L + J)) {
    sum <- 0
    count <- 0
    for (i in 1:(C - 2)) {
      for (l in 1:(C - 1 - i)) {
        if (i <= I && l <= L && C - i - l <= J) {
          sum <- sum + X[i, l, C - i - l]
          count <- count + 1
        }
      }
    }
    s[C - 2] <- sum / count
  }
  return(s)
}
```

# Комплексные модификации тензорных разложений
```{r fnorm_complex}
fnorm_complex <- function(x) {
  sqrt(sum(abs(x) ^ 2))
}

setMethod("fnorm_complex", "Tensor", function(x) {
  sqrt(sum(abs(x@data) ^ 2))
})
```

```{r hosvd-mod}
hosvd_mod <- function(tnsr, ranks = NULL, status = TRUE) 
{
    stopifnot(is(tnsr, "Tensor"))
    if (sum(ranks <= 0) != 0) 
        stop("ranks must be positive")
    if (all(tnsr@data == 0)) 
        stop("Zero tensor detected")
    num_modes <- tnsr@num_modes
    if (is.null(ranks)) {
        ranks <- tnsr@modes
    }
    else {
        if (sum(ranks > tnsr@modes) != 0) 
            stop("ranks must be smaller than the corresponding mode")
    }
    if (status) {
      pb <- txtProgressBar(min = 0, max = num_modes, style = 3)
      U_list <- vector("list", num_modes)
      for (m in 1:num_modes) {
        temp_mat <- rs_unfold(tnsr, m = m)@data
        U_list[[m]] <- svd(temp_mat, nu = ranks[m])$u
        setTxtProgressBar(pb, m)
      }
      close(pb)
    }
    else {
      U_list <- vector("list", num_modes)
      for (m in 1:num_modes) {
        temp_mat <- rs_unfold(tnsr, m = m)@data
        U_list[[m]] <- svd(temp_mat, nu = ranks[m])$u
      }
    }
    Z <- ttl(tnsr, lapply(U_list, (\(.) Conj(t(.)))), ms = 1:num_modes)
    est <- ttl(Z, U_list, ms = 1:num_modes)
    resid <- fnorm_complex(est - tnsr)
    list(Z = Z, U = U_list, est = est, fnorm_resid = resid)
}

tucker_mod <- function(tnsr, ranks = NULL, max_iter = 25, tol = 1e-05, status = TRUE) 
{
    stopifnot(is(tnsr, "Tensor"))
    if (is.null(ranks)) 
        stop("ranks must be specified")
    if (sum(ranks > tnsr@modes) != 0) 
        stop("ranks must be smaller than the corresponding mode")
    if (sum(ranks <= 0) != 0) 
        stop("ranks must be positive")
    if (all(tnsr@data == 0)) 
        stop("Zero tensor detected")
    num_modes <- tnsr@num_modes
    U_list <- vector("list", num_modes)
    for (m in 1:num_modes) {
        temp_mat <- rs_unfold(tnsr, m = m)@data
        U_list[[m]] <- svd(temp_mat, nu = ranks[m])$u
    }
    tnsr_norm <- fnorm_complex(tnsr)
    curr_iter <- 1
    converged <- FALSE
    fnorm_resid <- rep(0, max_iter)
    CHECK_CONV <- function(Z, U_list) {
        est <- ttl(Z, U_list, ms = 1:num_modes)
        curr_resid <- fnorm_complex(tnsr - est)
        fnorm_resid[curr_iter] <<- curr_resid
        if (curr_iter == 1) 
            return(FALSE)
        if (abs(curr_resid - fnorm_resid[curr_iter - 1])/tnsr_norm < 
            tol) 
            return(TRUE)
        else {
            return(FALSE)
        }
    }
    if (status) {
      pb <- txtProgressBar(min = 0, max = max_iter, style = 3)
      while ((curr_iter < max_iter) && (!converged)) {
        setTxtProgressBar(pb, curr_iter)
        modes <- tnsr@modes
        modes_seq <- 1:num_modes
        for (m in modes_seq) {
          X <- ttl(tnsr, lapply(U_list[-m], (\(.) Conj(t(.)))), ms = modes_seq[-m])
          U_list[[m]] <- svd(rs_unfold(X, m = m)@data, nu = ranks[m])$u
        }
        Z <- ttm(X, mat = Conj(t(U_list[[num_modes]])), m = num_modes)
        if (CHECK_CONV(Z, U_list)) {
          converged <- TRUE
          setTxtProgressBar(pb, max_iter)
        }
        else {
          curr_iter <- curr_iter + 1
        }
      }
      close(pb)
    }
    else {
      while ((curr_iter < max_iter) && (!converged)) {
        modes <- tnsr@modes
        modes_seq <- 1:num_modes
        for (m in modes_seq) {
          X <- ttl(tnsr, lapply(U_list[-m], (\(.) Conj(t(.)))), ms = modes_seq[-m])
          U_list[[m]] <- svd(rs_unfold(X, m = m)@data, nu = ranks[m])$u
        }
        Z <- ttm(X, mat = Conj(t(U_list[[num_modes]])), m = num_modes)
        if (CHECK_CONV(Z, U_list)) {
          converged <- TRUE
        }
        else {
          curr_iter <- curr_iter + 1
        }
      }
    }
    
    fnorm_resid <- fnorm_resid[fnorm_resid != 0]
    norm_percent <- (1 - (tail(fnorm_resid, 1)/tnsr_norm)) * 
        100
    est <- ttl(Z, U_list, ms = 1:num_modes)
    invisible(list(Z = Z, U = U_list, conv = converged, est = est, 
        norm_percent = norm_percent, fnorm_resid = tail(fnorm_resid, 
            1), all_resids = fnorm_resid))
}
```

# Проверка корректности модификаций
```{r test-hosvd-mod}
X.test <- rTensor::rand_tensor()
cat("Real example:\n")
waldo::compare(hosvd(X.test), hosvd_mod(X.test))

cat("\nComplex example:\n")
X.test.complex <- tens3(exp(1:10 * 1i), 3, 4)
waldo::compare(hosvd(X.test.complex), hosvd_mod(X.test.complex))
```

```{r test-hooi-mod}
X.test <- rTensor::rand_tensor()
cat("Real example:\n")
waldo::compare(tucker(X.test, c(3, 3, 3)), tucker_mod(X.test, c(3, 3, 3)))

cat("\nComplex example:\n1. Package function\n")
X.test.complex <- tens3(exp(1:10 * 1i), 3, 4)
try(tucker(X.test.complex, c(3, 3, 3)))
cat("2. Modified function\n")
try(tucker_mod(X.test.complex, c(3, 3, 3)))
cat("\nFnorm of the residual for modified function:\n")
tucker_mod(X.test.complex, c(1, 1, 1), status = FALSE)$fnorm_resid
```
# Тензорные модификации SSA и ESPRIT и вспомогательные функции
```{r tensor-based-esprit}
tens_esprit <- function(s, I, L, groups, kind = c("HO-SSA", "HO-MSSA"), est_dim, 
                        status = TRUE, qrtol = 1e-07) {
  if (identical(kind[1], "HO-SSA"))
    H <- tens3(s, I, L)
  else if (identical(kind[1], "HO-MSSA"))
  {
    if (missing(L))
      L <- I
    H <- tens3(s, L, kind = "HO-MSSA")
  }
  max_rank <- max(sapply(groups, max))
  H.hooi <- tucker_mod(H, rep(max_rank, 3), status = status)
  estimates <- list()
  for (i in seq(groups)) {
    U <- H.hooi$U[[est_dim]][, groups[[i]], drop = FALSE]
    Z <- qr.solve(U[-nrow(U), ], U[-1, ], qrtol)
    poles <- eigen(Z, only.values = TRUE)$values
    estimates[[i]] <- list(
      poles = poles,
      rates = Re(log(poles)),
      frequencies = Im(log(poles)) / 2 / pi
    )
  }
  estimates
}
```

```{r tensor-based-ssa}
tens_ssa_reconstruct <- function(s,
                                 I,
                                 L,
                                 groups,
                                 decomp = c("HOSVD", "HOOI"),
                                 trunc_dims = NULL,
                                 status = TRUE) {
  H <- tens3(s, I, L, kind = "HO-SSA")
  max_rank <- max(sapply(groups, max))
  if (is.null(trunc_dims))
    trunc_ranks <- rep(max_rank, 3)
  else {
    trunc_ranks <- dim(H)
    trunc_ranks[trunc_dims] <- max_rank
  }
  
  if (identical(decomp[1], "HOSVD"))
    H.dec <- hosvd_mod(H, ranks = trunc_ranks, status = status)
  else
    H.dec <- tucker_mod(H, ranks = trunc_ranks, status = status)
  
  rec <- list()
  if (is.null(names(groups)))
    group.names <- paste0("F", seq_along(groups))
  else
    group.names <- names(groups)
  
  for (i in seq_along(groups)) {
    group <- rep(list(groups[[i]]), 3)
    group[-trunc_dims] <- lapply(dim(H)[-trunc_dims], seq)
    H.rec <- ttl(H.dec$Z[group[[1]], group[[2]], group[[3]], drop = FALSE], list(
      as.matrix(H.dec$U[[1]][, group[[1]]]),
      as.matrix(H.dec$U[[2]][, group[[2]]]),
      as.matrix(H.dec$U[[3]][, group[[3]]])
    ), 1:3)
    rec[[i]] <- reconstruct.group3(H.rec)
  }
  
  names(rec) <- group.names
  rec
}
```

```{r complex-noise-generator}
CCSWGN <- function(n, mean = 0, sd = 1) {
  rnorm(n, mean = Re(mean), sd = sd / sqrt(2)) + 1i * rnorm(n, mean = Im(mean), sd = sd / sqrt(2))
}
```

```{r rrmse}
rrmse <- function(true, estimate) {
  100 * sqrt(mean(abs(true - estimate)^2)) / abs(true)
}
```

```{r plot-and-save}
plot.save <- function(plt, name, format, ..., save = TRUE) {
  print(plt)
  if (save){
    format(name, ...)
    print(plt)
    dev.off()
  }
}

save <- FALSE
```

# Сравнения одномерных методов
```{r test-1d-no-noise}
n <- 25
x <- exp((-0.01 + 2i * pi * 0.2) * 0:(n - 1)) + exp((-0.02 + 2i * pi * 0.22) * 0:(n - 1))
L <- 15
x.ssa <- ssa(x, L = L) 
pars <- parestimate(x.ssa, groups = list(1:2))
cat("Rates:\n", pars$rates, "\nFrequencies:\n", pars$frequencies)
```
```{r test-1d-tens-esprit-no-noise}
n <- 25
x <- exp((-0.01 + 2i * pi * 0.2) * 0:(n - 1)) + exp((-0.02 + 2i * pi * 0.22) * 0:(n - 1))
I <- 14; L <- 8
pars <- tens_esprit(x, I, L, groups = list(1:2), est_dim = 3, status = FALSE)
cat("Rates:\n", pars[[1]]$rates, "\nFrequencies:\n", pars[[1]]$frequencies)
```

```{r test-1d-noise, results='hide'}
set.seed(10)
n <- 25
L <- 15
I <- 14; L.tens <- 8
rates.true <- c(-0.01, -0.02)
freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))
sd <- 0.04
R <- 1000

pars.ssa <- list(
  rate1 = numeric(R),
  rate2 = numeric(R),
  freq1 = numeric(R),
  freq2 = numeric(R)
)
pars.tssa <- list(
  rate1 = numeric(R),
  rate2 = numeric(R),
  freq1 = numeric(R),
  freq2 = numeric(R)
)
pb <- txtProgressBar(max = R, style = 3)
for (i in seq(R)) {
  noise <- CCSWGN(n, mean = 0, sd = sd)
  x <- signal + noise
  x.ssa <- ssa(x, L = L)
  par.ssa <- parestimate(x.ssa, groups = list(1:2))
  pars.ssa$rate1[i] <- max(par.ssa$rates[1], par.ssa$rates[2])
  pars.ssa$rate2[i] <- min(par.ssa$rates[1], par.ssa$rates[2])
  pars.ssa$freq1[i] <- min(par.ssa$frequencies[1], par.ssa$frequencies[2])
  pars.ssa$freq2[i] <- max(par.ssa$frequencies[1], par.ssa$frequencies[2])
  par.tssa <- tens_esprit(x, I, L.tens, groups = list(1:2), est_dim = 3, status = FALSE)
  pars.tssa$rate1[i] <- max(par.tssa[[1]]$rates[1], par.tssa[[1]]$rates[2])
  pars.tssa$rate2[i] <- min(par.tssa[[1]]$rates[1], par.tssa[[1]]$rates[2])
  pars.tssa$freq1[i] <- min(par.tssa[[1]]$frequencies[1], par.tssa[[1]]$frequencies[2])
  pars.tssa$freq2[i] <- max(par.tssa[[1]]$frequencies[1], par.tssa[[1]]$frequencies[2])
  setTxtProgressBar(pb, i)
}
close(pb)
```
```{r, results='hold'}
cat("Rate 1, SSA: ", rrmse(rates.true[1], pars.ssa$rate1), '\n')
cat("Rate 1, HO-SSA: ", rrmse(rates.true[1], pars.tssa$rate1), '\n')
cat("Rate 2, SSA: ", rrmse(rates.true[2], pars.ssa$rate2), '\n')
cat("Rate 2, HO-SSA: ", rrmse(rates.true[2], pars.tssa$rate2), '\n')
cat("Freq 1, SSA: ", rrmse(freqs.true[1], pars.ssa$freq1), '\n')
cat("Freq 1, HO-SSA: ", rrmse(freqs.true[1], pars.tssa$freq1), '\n')
cat("Freq 2, SSA: ", rrmse(freqs.true[2], pars.ssa$freq2), '\n')
cat("Freq 2, HO-SSA: ", rrmse(freqs.true[2], pars.tssa$freq2), '\n')
```

# Проверка смешивания сигнала с шумом
```{r 1d-lambdas}
len.out <- 10
sds <- seq(from = 0,
           to = 0.2,
           length.out = len.out)

set.seed(10)

n <- 25
L <- 15
I <- 14; L.tens <- 8
tens.dims <- c(I, L.tens, n - I - L.tens + 2)

# no rates
rates.true <- c(0, 0)
scree.plot.name <- "_norates"
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# scree.plot.name <- "_smallrates"
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# scree.plot.name <- "_bigrates"
# rates from paper
# rates.true <- c(-0.01, -0.02)
# scree.plot.name <- "_diffrates"

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

R <- 500
l.range <- 2:4

lambda.mean <- list(
  ssa = matrix(numeric(length(l.range) * len.out), nrow = length(l.range)),
  tssa = list(
    dim1 = matrix(numeric(length(l.range) * len.out), nrow = length(l.range)),
    dim2 = matrix(numeric(length(l.range) * len.out), nrow = length(l.range)),
    dim3 = matrix(numeric(length(l.range) * len.out), nrow = length(l.range))
  )
)

noise.lambda.mean <- list(
  ssa = matrix(numeric(length(l.range) * len.out), nrow = length(l.range)),
  tssa = list(
    dim1 = matrix(numeric(length(l.range) * len.out), nrow = length(l.range)),
    dim2 = matrix(numeric(length(l.range) * len.out), nrow = length(l.range)),
    dim3 = matrix(numeric(length(l.range) * len.out), nrow = length(l.range))
  )
)

colnames(lambda.mean$ssa) <- round(sds, 2)
colnames(noise.lambda.mean$ssa) <- round(sds, 2)
lambda.mean$tssa <- lapply(lambda.mean$tssa, `colnames<-`, value = round(sds, 2))
noise.lambda.mean$tssa <- lapply(noise.lambda.mean$tssa, `colnames<-`, value = round(sds, 2))

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq_along(sds)) {
  sd <- sds[j]
  
  lambda.ssa <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  lambda.tssa.dim1 <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  lambda.tssa.dim2 <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  lambda.tssa.dim3 <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  
  noise.lambda.ssa <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  noise.lambda.tssa.dim1 <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  noise.lambda.tssa.dim2 <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  noise.lambda.tssa.dim3 <- matrix(numeric(length(l.range) * R), nrow = length(l.range))
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    
    lambda.ssa[, i] <- svd(Rssa::hankel(x, L))$d[l.range]
    
    Z <- hosvd_mod(tens3(x, I, L.tens), status = FALSE)$Z@data
    lambda.tssa.dim1[, i] <- apply(Z, 1, fnorm_complex)[l.range]
    lambda.tssa.dim2[, i] <- apply(Z, 2, fnorm_complex)[l.range]
    lambda.tssa.dim3[, i] <- apply(Z, 3, fnorm_complex)[l.range]
    
    if (sd > 0) {
      noise.lambda.ssa[, i] <- svd(Rssa::hankel(noise, L))$d[seq_along(l.range)]
    
      Z.noise <- hosvd_mod(tens3(noise, I, L.tens), status = FALSE)$Z@data
      noise.lambda.tssa.dim1[, i] <- apply(Z.noise, 1, fnorm_complex)[seq_along(l.range)]
      noise.lambda.tssa.dim2[, i] <- apply(Z.noise, 2, fnorm_complex)[seq_along(l.range)]
      noise.lambda.tssa.dim3[, i] <- apply(Z.noise, 3, fnorm_complex)[seq_along(l.range)]
    }
    
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
  lambda.mean$ssa[, j] <- rowMeans(lambda.ssa)
  lambda.mean$tssa$dim1[, j] <- rowMeans(lambda.tssa.dim1)
  lambda.mean$tssa$dim2[, j] <- rowMeans(lambda.tssa.dim2)
  lambda.mean$tssa$dim3[, j] <- rowMeans(lambda.tssa.dim3)
  
  noise.lambda.mean$ssa[, j] <- rowMeans(noise.lambda.ssa)
  noise.lambda.mean$tssa$dim1[, j] <- rowMeans(noise.lambda.tssa.dim1)
  noise.lambda.mean$tssa$dim2[, j] <- rowMeans(noise.lambda.tssa.dim2)
  noise.lambda.mean$tssa$dim3[, j] <- rowMeans(noise.lambda.tssa.dim3)
}
close(pb)
```


```{r scree-plots}
scree.plots <- list()

for (j in 1:len.out) {
  df.ssa <- data.frame(l_ssa = lambda.mean$ssa[, j])
  df.tssa <- data.frame(
    dim1 = lambda.mean$tssa$dim1[, j],
    dim2 = lambda.mean$tssa$dim2[, j],
    dim3 = lambda.mean$tssa$dim3[, j],
    index = l.range)
  
  scree.plots[[2 * j - 1]] <- df.ssa |> ggplot(aes(x = l.range, y = l_ssa)) +
    geom_point(size = 4) + geom_line() +
    labs(title = paste0("SSA, sd = ", round(sds[j], 2)),
         x = "Index", y = "Lambda") +
    ylim(c(min(lambda.mean$ssa), max(lambda.mean$ssa)))
  
  scree.plots[[2 * j]] <- df.tssa |> 
    pivot_longer(cols = dim1:dim3, names_to = "Dim", names_prefix = "dim",
                 values_to = "l_tssa") |>
    mutate(Dim_size = as.factor(tens.dims[as.integer(Dim)])) |>
    ggplot(aes(x = index, y = l_tssa, col = Dim_size)) +
    geom_point(aes(shape = Dim_size), size = 2.5) + geom_line(aes(linetype = Dim_size)) +
    labs(title = paste0("HO-SSA, sd = ", round(sds[j], 2)),
         x = "Index", y = "Lambda") +
    theme(legend.position = "inside", legend.position.inside = c(0.72, 0.88),
          legend.direction = "horizontal") +
    ylim(c(min(sapply(lambda.mean$tssa, min)), max(sapply(lambda.mean$tssa, max))))
}

layout_matrix <- matrix(seq_len(2 * 3), nrow = 3, byrow = TRUE)

ggsave(paste0("./img/Scree_plots", scree.plot.name, ".pdf"),
       marrangeGrob(grobs = scree.plots, ncol = 2, nrow = 3,
                    layout_matrix = layout_matrix,
                    top = quote(
                      paste0("Rates = (", rates.true[1], ", ", rates.true[2],
                                      "), page ", g, " of ", npages))),
       width = 9, height = 9)
```

## Отношения разниц сингулярных значений
```{r, results='hold', fig.width=10, fig.height=6, max.print=100}
cat("SSA\n|--Noise ratios:\n")
apply(noise.lambda.mean$ssa[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))
cat("\n|--Signal+Noise ratios:\n")
apply(lambda.mean$ssa[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))

cat("\n\nHO-SSA\n|--Noise ratios:\n")
apply(noise.lambda.mean$tssa$dim1[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))
apply(noise.lambda.mean$tssa$dim2[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))
apply(noise.lambda.mean$tssa$dim3[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))
cat("\n|--Signal+Noise ratios:\n")
apply(lambda.mean$tssa$dim1[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))
apply(lambda.mean$tssa$dim2[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))
apply(lambda.mean$tssa$dim3[, -1], 2, function(x)
  Reduce(`/`, -diff(x)))

plot(
  x = sds[-1],
  y = apply(lambda.mean$ssa[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  type = "l",
  ylim = c(0, max(
    apply(lambda.mean$ssa[, -1], 2, function(x)
      Reduce(`/`, -diff(x)))
  )),
  ylab = "Ratio",
  xlab = "sd"
)
lines(
  x = sds[-1],
  y = apply(lambda.mean$tssa$dim1[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "red"
)
lines(
  x = sds[-1],
  y = apply(lambda.mean$tssa$dim2[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "green"
)
lines(
  x = sds[-1],
  y = apply(lambda.mean$tssa$dim3[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "purple"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$ssa[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "black",
  lty = "dashed"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$tssa$dim1[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "red",
  lty = "dashed"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$tssa$dim2[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "green",
  lty = "dashed"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$tssa$dim3[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "purple",
  lty = "dashed"
)
legend(
  "topright",
  legend = c(
    "SSA",
    paste("TSSA", tens.dims[1]),
    paste("TSSA", tens.dims[2]),
    paste("TSSA", tens.dims[3]),
    "Noise - SSA",
    paste("Noise TSSA", tens.dims[1]),
    paste("Noise TSSA", tens.dims[2]),
    paste("Noise TSSA", tens.dims[3])
  ),
  col = c("black", "red", "green", "purple"),
  lty = c("solid", "solid", "solid", "solid", "dashed", "dashed", "dashed", "dashed")
)

plot(
  x = sds[-1],
  y = apply(lambda.mean$ssa[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  type = "l",
  xlim = c(0.12, 0.2),
  ylim = c(0, 16),
  ylab = "Ratio",
  xlab = "sd"
)
lines(
  x = sds[-1],
  y = apply(lambda.mean$tssa$dim1[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "red"
)
lines(
  x = sds[-1],
  y = apply(lambda.mean$tssa$dim2[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "green"
)
lines(
  x = sds[-1],
  y = apply(lambda.mean$tssa$dim3[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "purple"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$ssa[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "black",
  lty = "dashed"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$tssa$dim1[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "red",
  lty = "dashed"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$tssa$dim2[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "green",
  lty = "dashed"
)
lines(
  x = sds[-1],
  y = apply(noise.lambda.mean$tssa$dim3[, -1], 2, function(x)
    Reduce(`/`, -diff(x))),
  col = "purple",
  lty = "dashed"
)
legend(
  "topright",
  legend = c(
    "SSA",
    paste("TSSA", tens.dims[1]),
    paste("TSSA", tens.dims[2]),
    paste("TSSA", tens.dims[3]),
    "Noise - SSA",
    paste("Noise TSSA", tens.dims[1]),
    paste("Noise TSSA", tens.dims[2]),
    paste("Noise TSSA", tens.dims[3])
  ),
  col = c("black", "red", "green", "purple"),
  lty = c("solid", "solid", "solid", "solid", "dashed", "dashed", "dashed", "dashed")
)
```


# Сравнение одномерных методов для разных дисперсий
```{r 1d-comparison-for-sds, results='hide'}
len.out <- 16
sds <- seq(from = 0.01, to = 0.2, length.out = len.out)
# sds <- seq(from = 0.01, to = 0.06, length.out = len.out)
set.seed(10)

n <- 25
L <- 15
I <- 14; L.tens <- 8
tens.dims <- c(I, L.tens, n - I - L.tens + 2)

# no rates
# rates.true <- c(0, 0)
# plot.name <- "_no_rates"
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# plot.name <- "_small_eq_rates"
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# plot.name <- "_large_eq_rates"
# rates from paper
rates.true <- c(-0.01, -0.02)
plot.name <- ""

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

groups <- list(1:2)

R <- 500

rate1.rrmse <- list(ssa = numeric(len.out), tssa = matrix(numeric(len.out * 3), ncol = 3))
rate2.rrmse <- list(ssa = numeric(len.out), tssa = matrix(numeric(len.out * 3), ncol = 3))
freq1.rrmse <- list(ssa = numeric(len.out), tssa = matrix(numeric(len.out * 3), ncol = 3))
freq2.rrmse <- list(ssa = numeric(len.out), tssa = matrix(numeric(len.out * 3), ncol = 3))

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq_along(sds)) {
  pars.ssa <- list(
    rate1 = numeric(R),
    rate2 = numeric(R),
    freq1 = numeric(R),
    freq2 = numeric(R)
  )
  
  pars.tssa <- rep(list(list(
    rate1 = numeric(R),
    rate2 = numeric(R),
    freq1 = numeric(R),
    freq2 = numeric(R)
  )), 3)
  
  sd <- sds[j]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    x.ssa <- ssa(x, L = L)
    
    par.ssa <- parestimate(x.ssa, groups = groups)
    pars.ssa$rate1[i] <- max(par.ssa$rates[1], par.ssa$rates[2])
    pars.ssa$rate2[i] <- min(par.ssa$rates[1], par.ssa$rates[2])
    pars.ssa$freq1[i] <- min(par.ssa$frequencies[1], par.ssa$frequencies[2])
    pars.ssa$freq2[i] <- max(par.ssa$frequencies[1], par.ssa$frequencies[2])
    
    for (d in 1:3) {
      par.tssa <- tens_esprit(x,
                              I,
                              L.tens,
                              groups = groups,
                              est_dim = d,
                              status = FALSE)
      
      pars.tssa[[d]]$rate1[i] <- max(par.tssa[[1]]$rates[1], par.tssa[[1]]$rates[2])
      pars.tssa[[d]]$rate2[i] <- min(par.tssa[[1]]$rates[1], par.tssa[[1]]$rates[2])
      pars.tssa[[d]]$freq1[i] <- min(par.tssa[[1]]$frequencies[1], par.tssa[[1]]$frequencies[2])
      pars.tssa[[d]]$freq2[i] <- max(par.tssa[[1]]$frequencies[1], par.tssa[[1]]$frequencies[2])
    }
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
  rate1.rrmse$ssa[j] <- rrmse(rates.true[1], pars.ssa$rate1)
  rate2.rrmse$ssa[j] <- rrmse(rates.true[2], pars.ssa$rate2)
  freq1.rrmse$ssa[j] <- rrmse(freqs.true[1], pars.ssa$freq1)
  freq2.rrmse$ssa[j] <- rrmse(freqs.true[2], pars.ssa$freq2)
  
  for (d in 1:3) {
    rate1.rrmse$tssa[j, d] <- rrmse(rates.true[1], pars.tssa[[d]]$rate1)
    rate2.rrmse$tssa[j, d] <- rrmse(rates.true[2], pars.tssa[[d]]$rate2)
    freq1.rrmse$tssa[j, d] <- rrmse(freqs.true[1], pars.tssa[[d]]$freq1)
    freq2.rrmse$tssa[j, d] <- rrmse(freqs.true[2], pars.tssa[[d]]$freq2)
  }
}
close(pb)
```

## Графики мнимой и вещественной частей сигнала
```{r}
signal.plot.df <- data.frame(
  re_1 = Re(exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1))), 
  im_1 = Im(exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1))),
  re_2 = Re(exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))),
  im_2 = Im(exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))),
  index = 1:n) |> mutate(re_sum = re_1 + re_2, im_sum = im_1 + im_2)


signal.plot.df |> pivot_longer(c(re_1, re_2, re_sum), names_to = "Re_num", 
                               names_prefix = "re_", values_to = "Re") |>
  ggplot(aes(x = index)) + geom_line(aes(y = Re, col = Re_num, linetype = Re_num), lwd = 1.2)

signal.plot.df |> pivot_longer(c(im_1, im_2, im_sum), names_to = "Im_num", 
                               names_prefix = "im_", values_to = "Im") |>
  ggplot(aes(x = index)) + geom_line(aes(y = Im, col = Im_num, linetype = Im_num), lwd = 1.2)
```

## Графики RRMSE оценок параметров каждым из методов
```{r}
rate1.df <- rate1.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE") |>
  mutate(type = ifelse(grepl("tssa", type), paste("tssa", tens.dims[as.integer(substr(type, 6, 6))]), type))

rate1.plot <- rate1.df |> ggplot() +
  geom_line(aes(
    x = sd,
    y = RRMSE,
    colour = type,
    linetype = type
  ), lwd = 1.2)

rate1.plot.mini <- filter(rate1.df, sd <= 0.1) |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(
  rate1.plot,
  paste0("./img/rate1", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)

plot.save(
  rate1.plot.mini,
  paste0("./img/rate1", plot.name, "_mini.pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

```{r}
rate2.df <- rate2.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE") |>
  mutate(type = ifelse(grepl("tssa", type), paste("tssa", tens.dims[as.integer(substr(type, 6, 6))]), type))

rate2.plot <- rate2.df |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

rate2.plot.mini <- filter(rate2.df, sd <= 0.1) |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(
  rate2.plot,
  paste0("./img/rate2", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)

plot.save(
  rate2.plot.mini,
  paste0("./img/rate2", plot.name, "_mini.pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

```{r}
freq1.df <- freq1.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE") |>
  mutate(type = ifelse(grepl("tssa", type), paste("tssa", tens.dims[as.integer(substr(type, 6, 6))]), type))

freq1.plot <- freq1.df |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

freq1.plot.mini <- filter(freq1.df, sd <= 0.1) |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(
  freq1.plot,
  paste0("./img/freq1", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)

plot.save(
  freq1.plot.mini,
  paste0("./img/freq1", plot.name, "_mini.pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```
```{r}
freq2.df <- freq2.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE") |>
  mutate(type = ifelse(grepl("tssa", type), paste("tssa", tens.dims[as.integer(substr(type, 6, 6))]), type))

freq2.plot <- freq2.df |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

freq2.plot.mini <- filter(freq2.df, sd <= 0.1) |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(
  freq2.plot,
  paste0("./img/freq2", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)

plot.save(
  freq2.plot.mini,
  paste0("./img/freq2", plot.name, "_mini.pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

# Сравнение точности восстановления
```{r}
len.out <- 16
sds <- seq(from = 0, to = 0.2, length.out = len.out)
# sds <- seq(from = 0.01, to = 0.06, length.out = len.out)
set.seed(10)

n <- 25
# n <- 23
L <- 11
# L <- 12
I <- 14; L.tens <- 8
# I <- 12; L.tens <- 8
tens.dims <- c(I, L.tens, n - I - L.tens + 2)

# no rates
rates.true <- c(0, 0)
plot.name <- "_no_rates"
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# plot.name <- "_small_eq_rates"
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# plot.name <- "_large_eq_rates"
# rates from paper
# rates.true <- c(-0.01, -0.02)
# plot.name <- ""

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

# signal <- cos(2 * pi * (1:n) / 4 + pi / 3) + cos(2 * pi * (1:n) / 3)

groups <- list(1:2)
# groups <- list(1:2, 3:4)
trunc_dims <- list(1, 2, 3, 1:3)
# trunc_dims <- list(1, 2, 3, 1:2, 2:3, c(1, 3), 1:3)

R <- 500

rec.rmse <- list(ssa = numeric(len.out), 
                 tssa = matrix(numeric(len.out * length(trunc_dims)), nrow = len.out))

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq_along(sds)) {
  mse.ssa <- numeric(R)
  mse.tssa <- rep(list(numeric(R)), length(trunc_dims))
  
  sd <- sds[j]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    
    x.ssa <- ssa(x, L = L)
    
    rec.ssa <- reconstruct(x.ssa, groups = groups)
    mse.ssa[i] <- mean(abs(Reduce(`+`, rec.ssa) - signal)^2)
    
    for (d in seq_along(trunc_dims)) {
      rec.tssa <- tens_ssa_reconstruct(x, I, L.tens, groups = groups, decomp = "HOOI",
                                    trunc_dims = trunc_dims[[d]], status = FALSE)
      
      mse.tssa[[d]][i] <- mean(abs(Reduce(`+`, rec.tssa) - signal)^2)
    }
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
  rec.rmse$ssa[j] <- mse.ssa |> mean() |> sqrt()
  
  for (d in seq_along(trunc_dims)) {
    rec.rmse$tssa[j, d] <- mse.tssa[[d]] |> mean() |> sqrt()
  }
}

close(pb)
```

## Графики RMSE восстановленного ряда каждым из методов
```{r}
reconstr.df <- rec.rmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RMSE") |>
  mutate(type = ifelse(grepl("tssa", type), 
                       paste("tssa, dim:", trunc_dims[as.integer(substr(type, 6, 6))]), type))

reconstr.plot <- reconstr.df |> ggplot() +
  geom_line(aes(
    x = sd,
    y = RMSE,
    colour = type,
    linetype = type
  ), lwd = 1.2)

# reconstr.plot.mini <- filter(reconstr.df, sd <= 0.1) |> ggplot() + geom_line(aes(
#   x = sd,
#   y = RMSE,
#   colour = type,
#   linetype = type
# ), lwd = 1.2)

plot.save(
  reconstr.plot,
  paste0("./img/rec_rmse", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)

# plot.save(
#   reconstr.plot.mini,
#   paste0("./img/rec_rmse", plot.name, "_mini.pdf"),
#   pdf,
#   width = 9,
#   height = 6,
#   save = save
# )
```


# Комплексный многоканальный ESPRIT 
```{r complex-nd-esprit}
cmesprit <- function(s, L, groups, qrtol = 1e-07) {
  H <- apply(s, 2, Rssa::hankel, L = L, simplify = FALSE) |>
    Reduce(cbind, x = _) 
  
  max_rank <- max(sapply(groups, max))
  H.svd <- svd(H, nu = max_rank, nv = 0)
  estimates <- list()
  for (i in seq(groups)) {
    U <- H.svd$u[, groups[[i]], drop = FALSE]
    Z <- qr.solve(U[-nrow(U), ], U[-1, ], qrtol)
    poles <- eigen(Z, only.values = TRUE)$values
    estimates[[i]] <- list(
      poles = poles,
      rates = Re(log(poles)),
      frequencies = Im(log(poles)) / 2 / pi
    )
  }
  estimates
}
```


# Сравнение точности выделения сигнала для различных длин окна.
```{r}
sd <- 0.04
set.seed(10)

n <- 25

# no rates
rates.true <- c(0, 0)
plot.name <- "_no_rates"
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# plot.name <- "_small_eq_rates"
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# plot.name <- "_large_eq_rates"
# rates from paper
# rates.true <- c(-0.01, -0.02)
# plot.name <- ""

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

groups <- list(1:2)
max.r <- max(sapply(groups, max))
trunc_dims <- list(1, 1:2, 1:3)

# I >= L >= J
Is <- seq(from = max.r + 1, to = n - max.r - 1, by = 1)
Ls <- seq(from = max.r + 1, to = n - max.r - 1, by = 1)

correct.dims <- which(outer(Is, Ls, (
  \(i, l) ifelse((i >= l) &
                   (n - i - l + 2 > max.r) &
                   (n - i - l + 2 <= l), TRUE, FALSE)
)), arr.ind = TRUE)

len.out <- nrow(correct.dims)

tens.dims <- matrix(ncol = 3, nrow = len.out)
colnames(tens.dims) <- c("I", "L", "J")
tens.dims[, "I"] <- Is[correct.dims[,1]]
tens.dims[, "L"] <- Ls[correct.dims[,2]]
tens.dims[, "J"] <- n - tens.dims[, "I"] - tens.dims[, "L"] + 2

tens.dims <- tens.dims[order(tens.dims[,1], tens.dims[,2], decreasing = TRUE),]

R <- 500

rec.rmse <- matrix(numeric(len.out * length(trunc_dims)), nrow = len.out)

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq(len.out)) {
  mse.tssa <- rep(list(numeric(R)), length(trunc_dims))
  
  I <- tens.dims[j, 1]
  L <- tens.dims[j, 2]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    
    for (d in seq_along(trunc_dims)) {
      rec.tssa <- tens_ssa_reconstruct(x, I, L, groups = groups, decomp = "HOOI",
                                    trunc_dims = trunc_dims[[d]], status = FALSE)
      
      mse.tssa[[d]][i] <- mean(abs(Reduce(`+`, rec.tssa) - signal)^2)
    }
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
  for (d in seq_along(trunc_dims)) {
    rec.rmse[j, d] <- mse.tssa[[d]] |> mean() |> sqrt()
  }
}

close(pb)
```

## Нахождение минимума RMSE для SSA по возможным длинам окна
```{r}
sd <- 0.04
set.seed(10)

n <- 25

# no rates
rates.true <- c(0, 0)
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# rates from paper
# rates.true <- c(-0.01, -0.02)

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

groups <- list(1:2)
max.r <- max(sapply(groups, max))

# L <= K
Ls <- seq(from = max.r + 1, to = (n + 1) %/% 2, by = 1)

len.out <- length(Ls)

R <- 500

rec.ssa.rmse <- numeric(len.out)

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq(len.out)) {
  mse.ssa <- numeric(R)
  
  L <- Ls[j]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    
    x.ssa <- ssa(x, L = L)
    
    rec.ssa <- reconstruct(x.ssa, groups = groups)
    mse.ssa[i] <- mean(abs(Reduce(`+`, rec.ssa) - signal)^2)
   
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
    rec.ssa.rmse[j] <- mse.ssa |> mean() |> sqrt()
}


min.ssa.rmse <- c(min(rec.ssa.rmse), Ls[which.min(rec.ssa.rmse)])

close(pb)
```

## Графики RMSE
```{r}
rec1.df <- rec.rmse |> as.data.frame() |>
  mutate(dims = factor(x = apply(tens.dims, 1, paste, collapse = "x"),
                       levels = apply(tens.dims, 1, paste, collapse = "x"))) |>
  pivot_longer(!dims, names_to = "trunc dims", names_prefix = "V", values_to = "RMSE") |>
  mutate(`trunc dims` = as.factor(paste(trunc_dims[as.integer(`trunc dims`)])))

rec1.plot <- rec1.df |> ggplot() +
  geom_line(aes(
    x = dims,
    y = RMSE,
    group = `trunc dims`,
    colour = `trunc dims`,
    linetype = `trunc dims`
  ), lwd = 1.2) + 
  geom_abline(slope = 0, intercept = min.ssa.rmse[1], col = "gray10", lty = 3) +
  annotate(geom = "text", x = 5, y = min.ssa.rmse[1] * 1.02, label = "SSA min RMSE") +
  ylim(min.ssa.rmse[1], 0.0245) + 
  theme(axis.text.x = element_text(angle = 90))

plot.save(
  rec1.plot,
  paste0("./img/rec_dim_rmse", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

# Сравнение точности оценки параметров для различных длин окна.
```{r}
sd <- 0.04
set.seed(10)

n <- 25

# no rates
# rates.true <- c(0, 0)
# plot.name <- "_no_rates"
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# plot.name <- "_small_eq_rates"
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# plot.name <- "_large_eq_rates"
# rates from paper
rates.true <- c(-0.01, -0.02)
plot.name <- ""

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

groups <- list(1:2)
max.r <- max(sapply(groups, max))

# I >= L >= J
Is <- seq(from = max.r + 1, to = n - max.r - 1, by = 1)
Ls <- seq(from = max.r + 1, to = n - max.r - 1, by = 1)

correct.dims <- which(outer(Is, Ls, (
  \(i, l) ifelse((i >= l) &
                   (n - i - l + 2 > max.r) &
                   (n - i - l + 2 <= l), TRUE, FALSE)
)), arr.ind = TRUE)

len.out <- nrow(correct.dims)

tens.dims <- matrix(ncol = 3, nrow = len.out)
colnames(tens.dims) <- c("I", "L", "J")
tens.dims[, "I"] <- Is[correct.dims[,1]]
tens.dims[, "L"] <- Ls[correct.dims[,2]]
tens.dims[, "J"] <- n - tens.dims[, "I"] - tens.dims[, "L"] + 2

tens.dims <- tens.dims[order(tens.dims[,1], tens.dims[,2], decreasing = TRUE),]

R <- 500

rate1.rrmse <- matrix(numeric(len.out * 3), nrow = len.out)
rate2.rrmse <- matrix(numeric(len.out * 3), nrow = len.out)
freq1.rrmse <- matrix(numeric(len.out * 3), nrow = len.out)
freq2.rrmse <- matrix(numeric(len.out * 3), nrow = len.out)

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq(len.out)) {
  pars.tssa <- rep(list(list(
    rate1 = numeric(R),
    rate2 = numeric(R),
    freq1 = numeric(R),
    freq2 = numeric(R)
  )), 3)
  
  I <- tens.dims[j, 1]
  L <- tens.dims[j, 2]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    
    for (d in seq_along(trunc_dims)) {
      par.tssa <- tens_esprit(x,
                              I,
                              L,
                              groups = groups,
                              est_dim = d,
                              status = FALSE)
      
      pars.tssa[[d]]$rate1[i] <- max(par.tssa[[1]]$rates[1], par.tssa[[1]]$rates[2])
      pars.tssa[[d]]$rate2[i] <- min(par.tssa[[1]]$rates[1], par.tssa[[1]]$rates[2])
      pars.tssa[[d]]$freq1[i] <- min(par.tssa[[1]]$frequencies[1], par.tssa[[1]]$frequencies[2])
      pars.tssa[[d]]$freq2[i] <- max(par.tssa[[1]]$frequencies[1], par.tssa[[1]]$frequencies[2])
    }
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
  for (d in 1:3) {
    rate1.rrmse[j, d] <- rrmse(rates.true[1], pars.tssa[[d]]$rate1)
    rate2.rrmse[j, d] <- rrmse(rates.true[2], pars.tssa[[d]]$rate2)
    freq1.rrmse[j, d] <- rrmse(freqs.true[1], pars.tssa[[d]]$freq1)
    freq2.rrmse[j, d] <- rrmse(freqs.true[2], pars.tssa[[d]]$freq2)
  }
}

close(pb)
beep()
save(
  rate1.rrmse,
  rate2.rrmse,
  freq1.rrmse,
  freq2.rrmse,
  file = paste0("./Research/comp_results/dim_rrmse", plot.name, "_tens.RData")
)
```

## Нахождение минимума RRMSE для SSA по возможным длинам окна
```{r}
sd <- 0.04
set.seed(10)

n <- 25

# no rates
# rates.true <- c(0, 0)
# plot.name <- "_no_rates"
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# plot.name <- "_small_eq_rates"
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# plot.name <- "_large_eq_rates"
# rates from paper
rates.true <- c(-0.01, -0.02)
plot.name <- ""

freqs.true <- c(0.2, 0.22)
signal <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) +
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1))

groups <- list(1:2)
max.r <- max(sapply(groups, max))

# L <= K
Ls <- seq(from = max.r + 1, to = (n + 1) %/% 2, by = 1)

len.out <- length(Ls)

R <- 500

rate1.ssa.rrmse <- numeric(len.out)
rate2.ssa.rrmse <- numeric(len.out)
freq1.ssa.rrmse <- numeric(len.out)
freq2.ssa.rrmse <- numeric(len.out)

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq(len.out)) {
  pars.ssa <- list(
    rate1 = numeric(R),
    rate2 = numeric(R),
    freq1 = numeric(R),
    freq2 = numeric(R)
  )
  
  L <- Ls[j]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal + noise
    
    x.ssa <- ssa(x, L = L)
    
    par.ssa <- parestimate(x.ssa, groups = groups)
    pars.ssa$rate1[i] <- max(par.ssa$rates[1], par.ssa$rates[2])
    pars.ssa$rate2[i] <- min(par.ssa$rates[1], par.ssa$rates[2])
    pars.ssa$freq1[i] <- min(par.ssa$frequencies[1], par.ssa$frequencies[2])
    pars.ssa$freq2[i] <- max(par.ssa$frequencies[1], par.ssa$frequencies[2])
   
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
    rate1.ssa.rrmse[j] <- rrmse(rates.true[1], pars.ssa$rate1)
    rate2.ssa.rrmse[j] <- rrmse(rates.true[2], pars.ssa$rate2)
    freq1.ssa.rrmse[j] <- rrmse(freqs.true[1], pars.ssa$freq1)
    freq2.ssa.rrmse[j] <- rrmse(freqs.true[2], pars.ssa$freq2)
}


min.ssa.rrmse <- lapply(
  list(
    rate1 = rate1.ssa.rrmse,
    rate2 = rate2.ssa.rrmse,
    freq1 = freq1.ssa.rrmse,
    freq2 = freq2.ssa.rrmse
  ),
  (\(v) c(min(v), which.min(Ls[v])))
)

close(pb)
save(
  rate1.ssa.rrmse,
  rate2.ssa.rrmse,
  freq1.ssa.rrmse,
  freq2.ssa.rrmse,
  file = paste0("./Research/comp_results/dim_rrmse", plot.name, "_ssa.RData")
)
```



## Графики RRMSE
```{r}
pltnms <- c("_no_rates", "_small_eq_rates", "_large_eq_rates", "")
pn <- 1

load(file = paste0("./Research/comp_results/dim_rrmse", pltnms[pn], "_tens.RData"))
load(file = paste0("./Research/comp_results/dim_rrmse", pltnms[pn], "_ssa.RData"))
```


```{r}
rate1.df <- rate1.rrmse |> as.data.frame() |> 
   mutate(dims = factor(x = apply(tens.dims, 1, paste, collapse = "x"),
                       levels = apply(tens.dims, 1, paste, collapse = "x"))) |>
  pivot_longer(!dims, names_to = "estim dim", names_prefix = "V", values_to = "RRMSE")

rate1.plot <- rate1.df |> ggplot() +
  geom_line(aes(
    x = dims,
    y = RRMSE,
    group = `estim dim`,
    colour = `estim dim`,
    linetype = `estim dim`
  ), lwd = 1.2) + 
  geom_abline(slope = 0, intercept = min.ssa.rrmse$rate1[1], col = "gray10", lty = 3) + 
  annotate(geom = "text", x = 5, y = min.ssa.rrmse$rate1[1] * 1.05, label = "SSA min RRMSE") +
  theme(axis.text.x = element_text(angle = 90))

plot.save(
  rate1.plot,
  paste0("./img/rate1_dims", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

```{r}
rate2.df <- rate2.rrmse |> as.data.frame() |> 
   mutate(dims = factor(x = apply(tens.dims, 1, paste, collapse = "x"),
                       levels = apply(tens.dims, 1, paste, collapse = "x"))) |>
  pivot_longer(!dims, names_to = "estim dim", names_prefix = "V", values_to = "RRMSE")

rate2.plot <- rate2.df |> ggplot() +
  geom_line(aes(
    x = dims,
    y = RRMSE,
    group = `estim dim`,
    colour = `estim dim`,
    linetype = `estim dim`
  ), lwd = 1.2) + 
  geom_abline(slope = 0, intercept = min.ssa.rrmse$rate2[1], col = "gray10", lty = 3) + 
  annotate(geom = "text", x = 5, y = min.ssa.rrmse$rate2[1] * 1.05, label = "SSA min RRMSE") +
  theme(axis.text.x = element_text(angle = 90))

plot.save(
  rate2.plot,
  paste0("./img/rate2_dims", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

```{r}
freq1.df <- freq1.rrmse |> as.data.frame() |> 
   mutate(dims = factor(x = apply(tens.dims, 1, paste, collapse = "x"),
                       levels = apply(tens.dims, 1, paste, collapse = "x"))) |>
  pivot_longer(!dims, names_to = "estim dim", names_prefix = "V", values_to = "RRMSE")

freq1.plot <- freq1.df |> ggplot() +
  geom_line(aes(
    x = dims,
    y = RRMSE,
    group = `estim dim`,
    colour = `estim dim`,
    linetype = `estim dim`
  ), lwd = 1.2) + 
  geom_abline(slope = 0, intercept = min.ssa.rrmse$freq1[1], col = "gray10", lty = 3) + 
  annotate(geom = "text", x = 5, y = min.ssa.rrmse$freq1[1] * 1.05, label = "SSA min RRMSE") +
  theme(axis.text.x = element_text(angle = 90))

plot.save(
  freq1.plot,
  paste0("./img/freq1_dims", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

```{r}
freq2.df <- freq2.rrmse |> as.data.frame() |> 
   mutate(dims = factor(x = apply(tens.dims, 1, paste, collapse = "x"),
                       levels = apply(tens.dims, 1, paste, collapse = "x"))) |>
  pivot_longer(!dims, names_to = "estim dim", names_prefix = "V", values_to = "RRMSE")

freq2.plot <- freq2.df |> ggplot() +
  geom_line(aes(
    x = dims,
    y = RRMSE,
    group = `estim dim`,
    colour = `estim dim`,
    linetype = `estim dim`
  ), lwd = 1.2) + 
  geom_abline(slope = 0, intercept = min.ssa.rrmse$freq2[1], col = "gray10", lty = 3) + 
  annotate(geom = "text", x = 5, y = min.ssa.rrmse$freq2[1] * 1.05, label = "SSA min RRMSE") +
  theme(axis.text.x = element_text(angle = 90))

plot.save(
  freq2.plot,
  paste0("./img/freq2_dims", plot.name, ".pdf"),
  pdf,
  width = 9,
  height = 6,
  save = save
)
```

# Сравнение многомерных методов
```{r test-nd-ssa-esprit-no-noise}
set.seed(10)

n <- 25
Q <- 12
coef <- matrix(CCSWGN(2 * Q), ncol = 2)

x <- exp((-0.01 + 2i * pi * 0.2) * 0:(n - 1)) %o% coef[, 1] + 
  exp((-0.02 + 2i * pi * 0.22) * 0:(n - 1)) %o% coef[, 2]
L <- 13
pars <- cmesprit(x, L = L, groups = list(1:2))[[1]]
cat("Rates:\n", pars$rates, "\nFrequencies:\n", pars$frequencies)
```

```{r test-nd-tens-esprit-no-noise}
set.seed(10)

n <- 25
Q <- 12
coef <- matrix(CCSWGN(2 * Q), ncol = 2)

x <- exp((-0.01 + 2i * pi * 0.2) * 0:(n - 1)) %o% coef[, 1] + 
  exp((-0.02 + 2i * pi * 0.22) * 0:(n - 1)) %o% coef[, 2]
L <- 13
pars <- tens_esprit(x, I, L, groups = list(1:2), kind = "HO-MSSA", est_dim = 1, status = FALSE)
cat("Rates:\n", pars[[1]]$rates, "\nFrequencies:\n", pars[[1]]$frequencies)
```


```{r nd-comparison-for-sds}
len.out <- 16
sds <- seq(from = 0.1, to = 0.4, length.out = len.out)
set.seed(10)

n <- 25
Q <- 12
L <- 13
L.tens <- 13

# no rates
rates.true <- c(0, 0)
# both rates -0.01
# rates.true <- c(-0.01, -0.01)
# both rates -0.02
# rates.true <- c(-0.02, -0.02)
# rates from paper
# rates.true <- c(-0.01, -0.02)

freqs.true <- c(0.2, 0.22)

coef <- matrix(CCSWGN(2 * Q), ncol = 2)

signal.mult <- exp((rates.true[1] + 2i * pi * freqs.true[1]) * 0:(n - 1)) %o% coef[, 1] + 
  exp((rates.true[2] + 2i * pi * freqs.true[2]) * 0:(n - 1)) %o% coef[, 2]

R <- 1000

rate1.mult.rrmse <- list(mssa = numeric(len.out), tmssa = numeric(len.out))
rate2.mult.rrmse <- list(mssa = numeric(len.out), tmssa = numeric(len.out))
freq1.mult.rrmse <- list(mssa = numeric(len.out), tmssa = numeric(len.out))
freq2.mult.rrmse <- list(mssa = numeric(len.out), tmssa = numeric(len.out))

pb <- txtProgressBar(max = R * len.out, style = 3)

for (j in seq_along(sds)) {
  pars.mssa <- list(
    rate1 = numeric(R),
    rate2 = numeric(R),
    freq1 = numeric(R),
    freq2 = numeric(R)
  )
  
  pars.tmssa <- list(
    rate1 = numeric(R),
    rate2 = numeric(R),
    freq1 = numeric(R),
    freq2 = numeric(R)
  )
  
  sd <- sds[j]
  
  for (i in seq(R)) {
    noise <- CCSWGN(n, mean = 0, sd = sd)
    x <- signal.mult + noise
    
    par.mssa <- cmesprit(x, L = L, groups = list(1:2))
    pars.mssa$rate1[i] <- max(par.mssa[[1]]$rates[1], par.mssa[[1]]$rates[2])
    pars.mssa$rate2[i] <- min(par.mssa[[1]]$rates[1], par.mssa[[1]]$rates[2])
    pars.mssa$freq1[i] <- min(par.mssa[[1]]$frequencies[1], par.mssa[[1]]$frequencies[2])
    pars.mssa$freq2[i] <- max(par.mssa[[1]]$frequencies[1], par.mssa[[1]]$frequencies[2])
    
    par.tmssa <- tens_esprit(x, L.tens, kind = "HO-MSSA", est_dim = 1, groups = list(1:2), status = FALSE)
    pars.tmssa$rate1[i] <- max(par.tmssa[[1]]$rates[1], par.tmssa[[1]]$rates[2])
    pars.tmssa$rate2[i] <- min(par.tmssa[[1]]$rates[1], par.tmssa[[1]]$rates[2])
    pars.tmssa$freq1[i] <- min(par.tmssa[[1]]$frequencies[1], par.tmssa[[1]]$frequencies[2])
    pars.tmssa$freq2[i] <- max(par.tmssa[[1]]$frequencies[1], par.tmssa[[1]]$frequencies[2])
    
    setTxtProgressBar(pb, (j - 1) * R + i)
  }
  
  rate1.mult.rrmse$mssa[j] <- rrmse(rates.true[1], pars.mssa$rate1)
  rate1.mult.rrmse$tmssa[j] <- rrmse(rates.true[1], pars.tmssa$rate1)
  rate2.mult.rrmse$mssa[j] <- rrmse(rates.true[2], pars.mssa$rate2)
  rate2.mult.rrmse$tmssa[j] <- rrmse(rates.true[2], pars.tmssa$rate2)
  freq1.mult.rrmse$mssa[j] <- rrmse(freqs.true[1], pars.mssa$freq1)
  freq1.mult.rrmse$tmssa[j] <- rrmse(freqs.true[1], pars.tmssa$freq1)
  freq2.mult.rrmse$mssa[j] <- rrmse(freqs.true[2], pars.mssa$freq2)
  freq2.mult.rrmse$tmssa[j] <- rrmse(freqs.true[2], pars.tmssa$freq2)
}
close(pb)
```

## Графики RRMSE оценок параметров каждым из методов
```{r}
rate1.df <- rate1.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE")
rate1.plot <- rate1.df |> ggplot() +
  geom_line(aes(
    x = sd,
    y = RRMSE,
    colour = type,
    linetype = type
  ), lwd = 1.2)

plot.save(rate1.plot,
          "./img/rate1_nd.pdf",
          pdf,
          width = 9,
          height = 6, save = save)
```

```{r}
rate2.df <- rate2.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE")
rate2.plot <- rate2.df |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(rate2.plot,
          "./img/rate2_nd.pdf",
          pdf,
          width = 9,
          height = 6, save = save)
```

```{r}
freq1.df <- freq1.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE")
freq1.plot <- freq1.df |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(freq1.plot,
          "./img/freq1_nd.pdf",
          pdf,
          width = 9,
          height = 6, save = save)
```

```{r}
freq2.df <- freq2.rrmse |> as.data.frame() |> mutate(sd = sds) |>
  pivot_longer(!sd, names_to = "type", values_to = "RRMSE")
freq2.plot <- freq2.df |> ggplot() + geom_line(aes(
  x = sd,
  y = RRMSE,
  colour = type,
  linetype = type
), lwd = 1.2)

plot.save(freq2.plot,
          "./img/freq2_nd.pdf",
          pdf,
          width = 9,
          height = 6, save = save)
```
